Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
mqencase,Encase,mqencase,Temporarily makes random equipment much harder to play.,YES,YES,NO,NO,YES,,,,if (status.value > 0) sfx(~_mqencase~); var encaseDataArray = []; var vulnerableEquipment = []; for (eq in self.equipment) if (eq.skillcard == ~~ && !eq.hastag(~skillcard~) && eq.shockedsetting == 0 && eq.ready && eq.active && eq.availablethisturn) vulnerableEquipment.push(eq); vulnerableEquipment = shuffle(vulnerableEquipment); for (i in 0...status.value) {if (vulnerableEquipment.length <= 0) break; var eq = vulnerableEquipment.pop(); var newslots = []; for (slot in eq.getslots()) switch (slot) {case ~NORMAL~ | ~MIN1~ | ~MIN2~ | ~MIN3~ | ~MIN4~ | ~MIN5~ | ~EVEN~: newslots.push(~REQUIRE6~); case ~MAX5~ | ~RANGE25~ | ~RANGE35~ | ~RANGE45~ | ~ODD~: newslots.push(~REQUIRE5~); case ~MAX4~ | ~RANGE24~ | ~RANGE34~: newslots.push(~REQUIRE4~); case ~MAX3~ | ~RANGE23~: newslots.push(~REQUIRE3~); case ~MAX2~: newslots.push(~REQUIRE2~); case ~REQUIRE6~ | ~REQUIRE5~ | ~REQUIRE4~ | ~REQUIRE3~ | ~REQUIRE2~ | ~REQUIRE1~ | ~MAX1~: {newslots.push(slot); newslots.push(slot);} case ~DOUBLES~: {newslots.push(~REQUIRE6~); newslots.push(~REQUIRE6~);} default: newslots.push(slot);} var encaseDataCurrent = {e: eq[;] originalslots: eq.getslots()[;] originalcountdown: eq.countdown[;] originalmaxcountdown: eq.maxcountdown[;] originalremainingcountdown: eq.remainingcountdown}; encaseDataArray.push(encaseDataCurrent); eq.changeslots(newslots); if (encaseDataCurrent.originalcountdown > 0) {eq.countdown = encaseDataCurrent.originalcountdown * 2; eq.maxcountdown = encaseDataCurrent.originalmaxcountdown * 2; eq.remainingcountdown = eq.maxcountdown;} eq.animate(~flashandshake~); runscript(~megaquest/textparticle~[;] [eq[;] ~[mqencase] Encase!~[;] 0x7FFFC5]);} self.setvar(~mqencase~[;] encaseDataArray);,,,if (self.getvar(~mqencase~).length != null) for (encaseData in self.getvar(~mqencase~)) {encaseData.e.changeslots(encaseData.originalslots); encaseData.e.countdown = encaseData.originalcountdown; encaseData.e.maxcountdown = encaseData.originalmaxcountdown; if (encaseData.e.remainingcountdown > encaseData.originalremainingcountdown) encaseData.e.remainingcountdown = encaseData.originalremainingcountdown;} self.setvar(~mqencase~[;] 0);,,,,
alternate_mqencase,Encase?,mqencase,Temporarily disables random equipment.|Deal damage to unlock encased equipment.,YES,NO,NO,NO,YES,,,,self.setvar(~alternate_mqencase_damage~[;] status.value); if (status.value > 0) sfx(~_mqencase~); var vulnerableEquipment = []; for (eq in self.equipment) if (eq.skillcard == ~~ && !eq.hastag(~skillcard~) && eq.shockedsetting == 0 && eq.ready && eq.active && eq.availablethisturn) vulnerableEquipment.push(eq); vulnerableEquipment = shuffle(vulnerableEquipment); for (i in 0...1) {if (vulnerableEquipment.length <= 0) break; var eq = vulnerableEquipment.pop(); eq.availablethisturn = false; eq.unavailabletext = eq.displayname + eq.namemodifier; eq.unavailabledetails = [~Do [sword]~ + self.getvar(~alternate_mqencase_damage~) + ~ damage~[;] ~to release encasement~]; eq.setvar(~alternate_mqencase~[;] 1); eq.animate(~flashandshake~); runscript(~megaquest/textparticle~[;] [eq[;] ~[mqencase] Encase!~[;] 0x7FFFC5]);},,,for (eq in self.equipment) if (eq.getvar(~alternate_mqencase~) > 0) eq.setvar(~alternate_mqencase~[;] 0);,,if (self.getvar(~mqmyturn~) == 1) {if (self.getvar(~alternate_mqencase_damage~) > 0) {self.setvar(~alternate_mqencase_damage~[;] self.getvar(~alternate_mqencase_damage~) - dmg); for (eq in self.equipment) if (eq.getvar(~alternate_mqencase~) > 0) {eq.unavailabledetails = [~Do [sword]~ + self.getvar(~alternate_mqencase_damage~) + ~ damage~[;] ~to release encasement~]; eq.animate(~flashandshake~);} if (self.getvar(~alternate_mqencase_damage~) <= 0) {self.setvar(~alternate_mqencase_damage~[;] 0); for (eq in self.equipment) if (eq.getvar(~alternate_mqencase~) > 0) {eq.setvar(~alternate_mqencase~[;] 0); eq.availablethisturn = true; eq.animate(~flashandshake~);} sfx(~_mqencasebreak~);}} runscript(~megaquest/delaycall~[;] [function (args) {args[0](~mqencase~[;] ALL); if (args[2] > 0) args[1](~mqencase~[;] args[2]);}[;] 0[;] removestatusself[;] inflictself[;] self.getvar(~alternate_mqencase_damage~)]);},,
mqcoatingfire,Hellsteel_Coating,mqcoatingfire,Inflict [fire]burn with each attack this turn.,NO,YES,NO,NO,NO,,,,,,,,,inflict(FIRE); sfx(~_fire~[;] ~~[;] 0.2);,,
mqcoatingice,Moonstone_Coating,mqcoatingice,Inflict [ice]freeze with each attack this turn.,NO,YES,NO,NO,NO,,,,,,,,,inflict(ICE); sfx(~_ice~[;] ~~[;] 0.2);,,
mqcoatingheal,Lifesteel_Coating,mqcoatingheal,Recover [heal]1 health with each attack this turn.,NO,YES,NO,NO,NO,,,,,,,,,attackself(-1); sfx(~_heal~[;] ~~[;] 0.2);,,
mqghastlyarmor,mqghastlyarmor,mqghastlyarmor,(should not appear),NO,NO,NO,YES,NO,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {if (self.equipment.length > 0) for (eq in self.equipment) if (eq.name == ~Ghastly Armor~ && eq.ready && eq.active && eq.namemodifier != ~-~) runscript(~megaquest/reducecountdown~[;] [eq[;] eq.namemodifier != ~+~ ? 4 : 5]);},,
mqwolfpuppyremix,mqwolfpuppyremix,sword,(should not appear),NO,NO,NO,YES,NO,,,,,,,,,if (dmg <= 4) {if (target.getvar(~mqwolfpuppyremix_ignore~) == 0) {target.setvar(~mqwolfpuppyremix_ignore~[;] 1); attack(dmg);} else target.setvar(~mqwolfpuppyremix_ignore~[;] 0);},,
mqgotchaused,mqgotchaused,sword,(should not appear),NO,NO,NO,YES,NO,,,,,,,,,,,
mqharpoonitemsused,mqharpoonitemsused,sword,(should not appear),YES,NO,NO,YES,NO,,,,,,,,,,,
mqcleaningservicesused,mqcleaningservicesused,sword,(should not appear),YES,NO,NO,YES,NO,,,,,,,,,,,
mqcpu+,Increase_CPU_by,mqcpu+,More max CPU this fight.,YES,NO,NO,NO,NO,,,,,,,,,,,
mqcpu-,Reduce_CPU_by,mqcpu-,Less max CPU this fight.,YES,NO,NO,NO,NO,,,,,,,,,,,
mqjam,Jammed,mqjam,Next attack also does [sword]<value>x damage to you.,YES,YES,NO,NO,YES,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {attackself(dmg * status.value); sfxdamage(self[;] dmg * status.value); removestatusself(~mqjam~[;] status.value);},,
alternate_mqjam,Jammed?,mqjam,Next attack does <value>x less damage.,YES,YES,NO,NO,YES,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {var reduction = 1 - 1 / getstatusself(~mqjam~); target.hp += -dmg * reduction; removestatusself(~mqjam~[;] ALL);},,
mqdrakeremix,Lifesteal,heart,Attacks regenerate health.,NO,NO,NO,YES,NO,,,,,,,,,attackself(-2); sfx(~_drain~);,,
mqdirewolfcurse,Cursed_Bite,mqdirewolfcurse,Your equipment is replaced with enemy equipment.,NO,YES,NO,NO,YES,,,,sfx(~_curse~); screenshake(); self.setvar(~mqdirewolfcurse_equipment~[;] self.equipment.copy()); self.setvar(~mqdirewolfcurse_layout~[;] self.layout); self.equipment = []; if (target.equipment.length > 0) for (eq in target.equipment) if (eq.skillcard == ~~ && !eq.hastag(~skillcard~) && self.spaceleft() >= eq.size && !eq.temporary_thisturnonly) giveequipment(eq.displayname + eq.namemodifier[;] false[;] false); if (self.usecpuinsteadofdice) self.equipment.push(self.createskillcard(~Robot Calculate~)); self.getequipmentposition(); self.layout = self.layout.EQUIPMENT; if (self.equipment.length > 0) for (eq in self.equipment.copy()) if (eq.skillcard == ~~ && eq.ready) {eq.animate(~flashandshake~); eq.animate(~~); /*eq.animation[eq.animation.length - 1].addcommand(~textparticle~[;] ~[curse] Cursed Bite!~[;] 16777215);*/ eq.x = eq.finalpos.x; eq.y = eq.finalpos.y; var curseAnim = new elements.Equipment(~~); curseAnim.width = eq.width; curseAnim.height = eq.height; curseAnim.x = eq.x; curseAnim.y = eq.y; curseAnim.ready = false; curseAnim.temporary_thisturnonly = true; curseAnim.animate(~curse~); curseAnim.animation[curseAnim.animation.length - 1].command[2] = ~~; self.equipment.push(curseAnim);},,,,,,,self.equipment = self.getvar(~mqdirewolfcurse_equipment~); self.setvar(~mqdirewolfcurse_equipment~[;] 0); self.layout = self.getvar(~mqdirewolfcurse_layout~); self.setvar(~mqdirewolfcurse_layout~[;] 0);
mqequipmentchangeswhencursed,mqequipmentchangeswhencursed,curse,(should not appear),NO,NO,NO,YES,NO,,if (self.getvar(~mqmyturn~) == 1) {if (inflicted_type == CURSE # inflicted_type == ~alternate_~ + CURSE) {if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready && eq.active) {if (eq.name == ~Demon Incarnate~) {eq.changeslots([eq.getslots()[0]]); eq.animate(~flashandshake~); eq.animate(~slotschanged~);} else if (eq.name == ~spookknife~) {eq.reuseable = -1; eq.usesleft = -1; eq.updatereuseabledescription(); eq.animate(~flashandshake~);}}}},,if (getstatusself(CURSE) > 0) {if (self.equipment.length > 0) for (eq in self.equipment) if (eq.ready && eq.active) {if (eq.name == ~Demon Incarnate~) {eq.changeslots([eq.getslots()[0]]); eq.animate(~flashandshake~); eq.animate(~slotschanged~);} else if (eq.name == ~spookknife~) {eq.reuseable = -1; eq.usesleft = -1; eq.updatereuseabledescription(); eq.animate(~flashandshake~);}}},,,,,,,
mqmadisonremix,Cookie_Box,mqmadisonremix,Start each turn with [fury]Fury.|(<value> turns left),YES,NO,NO,NO,NO,,,,inflictself(FURY); sfx(~_fury~); removestatusself(~mqmadisonremix~[;] 1); self.setvar(~mqmadisonremix~[;] self.getvar(~mqmadisonremix~) - 1);,,,,,,,
mqcorneliusremix,Impending_Doom,curse,Die in <value> turns.,YES,NO,NO,NO,NO,,,,removestatusself(~mqcorneliusremix~[;] 1);,,,,,,,pierceattackself(self.hp); sfxdamage(self[;] self.hp);
mqhandymanremix,mqhandymanremix,mqbonk,(should not appear),NO,NO,NO,YES,NO,,,,,,,,,if (dmg >= 6) {inflict(SHOCK); sfx(~_shock~[;] ~~[;] 0.2);},,
mqbountyhunterremix,Bounty,mqbountyhunterremix,No gold reward unless it's turn 3.,YES,NO,NO,NO,NO,self.gold = -1;,,,,,,if ((turn + 1) > status.value) inflictself(status.type[;] (turn + 1) - status.value); if ((turn + 1) == 3) {removestatusself(~mqbountyhunterremix~[;] ALL); inflictself(~mqbountyhunterremix2~[;] (turn + 1));},,,,
mqbountyhunterremix2,Bounty,gold,Defeat on this turn to gain gold!,YES,NO,NO,NO,NO,self.gold = 2;,,,,,,if ((turn + 1) > status.value) inflictself(status.type[;] (turn + 1) - status.value); if ((turn + 1) != 3) {removestatusself(~mqbountyhunterremix2~[;] ALL); inflictself(~mqbountyhunterremix~[;] (turn + 1));},,,,
mqaudreyremix1,Combo,mqaudreyremix1,Inflict [weaken]1 weaken every 3 attacks.,YES,NO,NO,NO,NO,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {runscript(~megaquest/delaycall~[;] [function (args) {args[0](~mqaudreyremix2~[;] 2); args[1](args[2][;] args[3]);}[;] 0[;] inflictself[;] removestatusself[;] status.type[;] ALL]);},,
mqaudreyremix2,Combo,mqaudreyremix2,Inflict [weaken]1 weaken every 3 attacks.,YES,NO,NO,NO,NO,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {runscript(~megaquest/delaycall~[;] [function (args) {args[0](~mqaudreyremix3~[;] 3); args[1](args[2][;] args[3]);}[;] 0[;] inflictself[;] removestatusself[;] status.type[;] ALL]);},,
mqaudreyremix3,Combo,mqaudreyremix3,Inflict [weaken]1 weaken every 3 attacks.,YES,NO,NO,NO,NO,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {runscript(~megaquest/delaycall~[;] [function (args) {args[0](~mqaudreyremix1~[;] 1); args[1](args[2][;] args[3]);}[;] 0[;] inflictself[;] removestatusself[;] status.type[;] ALL]); inflict(WEAKEN); sfx(~_weaken~[;] ~~[;] 0.2);},,
mqaoiferemix,mqaoiferemix,mqregenshield,(should not appear),NO,NO,NO,YES,NO,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);,runscript(~megaquest/remixes/aoife~[;] [self[;] attackself]);
mqdryadremix,mqdryadremix,heal,(should not appear),NO,NO,NO,YES,NO,,,if (self.hasstatus(POISON) && (turn > 1 # !self.isplayer)) {attack(-3); sfx(~_heal~[;] ~~[;] 0.2);},,,,,,,,
mqshortfuseused,mqshortfuseused,sword,(should not appear),YES,NO,NO,YES,NO,,,,,,,,,,,
mqjesterremix,mqjesterremix,dice,(should not appear),NO,NO,NO,YES,NO,,,,if (self.equipment.length > 0) {var alleq = []; for (eq in self.equipment) if (eq.skillcard == ~~ && !eq.hastag(~skillcard~)) alleq.push(eq); if (alleq.length > 0) {shuffle(alleq); runscript(~megaquest/snap~[;] [alleq.pop()[;] self[;] target[;] false]);}},,,,,,,
mqwarrior_vampireslayer,mqwarrior_vampireslayer,curse,(should not appear),NO,NO,NO,YES,NO,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {attackself(-2); sfx(~_drain~[;] ~~[;] 0.2);},,
mqfear,Fear,curse,Forced to solve a puzzle this turn (difficulty [curse]<value>[]).|Solve the puzzle by using all dice and equipment.|Take [sword]10 damage if you don't solve the puzzle.,YES,NO,NO,NO,YES,sfx(~lowhealth_end~); sfx(~lowhealth_start~); inflictself(~mqfear_remove~);,,self.setvar(~mqfear_equipment~[;] self.equipment.copy()); self.setvar(~mqfear_layout~[;] self.layout); self.setvar(~mqfear_dice~[;] self.dice); self.setvar(~mqfear_extradice~[;] self.extradice); self.setvar(~mqfear_bonusdice~[;] self.bonusdice); self.setvar(~mqfear_limitvalue~[;] self.limitvalue); self.setvar(~mqfear_status~[;] self.status.copy()); self.equipment = []; self.layout = target.layout.EQUIPMENT; self.dice = 0; self.extradice = 0; self.bonusdice = 0; self.limitvalue = 0; if (self.status.length > 0) for (st in self.status.copy()) if (st.type != ~mqfear~ && st.type != ~mqfear_remove~) self.removestatus(st.type); runscript(~megaquest/fear~[;] [status.value[;] loaddata[;] self[;] target[;] giveequipment[;] [][;] turn]);,,,,,,,,sfx(~lowhealth_end~);
mqfear_remove,mqfear_remove,curse,(should not appear),NO,YES,NO,YES,NO,,,,,,,,,,,self.equipment = self.getvar(~mqfear_equipment~); self.setvar(~mqfear_equipment~[;] 0); self.layout = self.getvar(~mqfear_layout~); self.setvar(~mqfear_layout~[;] 0); self.dice = self.getvar(~mqfear_dice~); self.setvar(~mqfear_dice~[;] 0); self.extradice = self.getvar(~mqfear_extradice~); self.setvar(~mqfear_extradice~[;] 0); self.bonusdice = self.getvar(~mqfear_bonusdice~); self.setvar(~mqfear_bonusdice~[;] 0); self.limitvalue = self.getvar(~mqfear_limitvalue~); self.setvar(~mqfear_limitvalue~[;] 0); var et = getstatusself(EXTRATURN); self.status = self.getvar(~mqfear_status~); if (et > 0) self.addstatus(EXTRATURN[;] et); else {sfx(~roboterror~); attackself(11); sfxdamage(self[;] 11);} self.setvar(~mqfear_status~[;] 0); removestatusself(~mqfear~[;] ALL);
mqrightbackatyou,mqrightbackatyou,sword,(should not appear),NO,NO,NO,YES,NO,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {var selfdamage = runscript(~megaquest/math/ceil~[;] [dmg / 2]); var eq = runscript(~megaquest/createequipment~[;] [~~[;] false[;] false[;] 3180 / 7 * runscript(~megaquest/math/random~[;] [1[;] 6])[;] -618[;] self[;] true]); eq.displayname = ~Right Back at You~; eq.fulldescription = ~Take [sword]~ + selfdamage + ~ damage~; eq.script = ~attackself(~ + selfdamage + ~); sfxdamage(self[;] ~ + selfdamage + ~);~; eq.castdirection = -1; eq.changeslots([~NORMAL~]); runscript(~megaquest/snap~[;] [eq[;] self[;] target[;] false]);},,
mqweakfire,Weak_to_fire,mqweakfire,Take double damage from [fire]fire attacks.,NO,NO,NO,NO,NO,self.innate.push(~weakfire~);,,,,,,,,,,self.innate.remove(~weakfire~);
mqsignallamp,Signal_Lamp,mqlantern,At the start of the next turn[;]|all dice become <value>.,YES,NO,NO,NO,NO,,,,if (self.dicepool.length > 0) for (mydice in self.dicepool) {mydice.basevalue = status.value; mydice.flash += 0.1;} sfx(~openchest~); runscript(~megaquest/removestatusself_delayed~[;] [removestatusself[;] ~mqsignallamp~[;] ALL]);,,,,,,,
mqendturnselfdamage,mqendturnselfdamage,sword,(should not appear),YES,NO,NO,YES,NO,,,,,,,attackself(status.value); sfxdamage(self[;] status.value); sfx(~_metals~); runscript(~megaquest/removestatusself_delayed~[;] [removestatusself[;] ~mqendturnselfdamage~[;] ALL]);,,,,
mqinsanity,Insanity,mqinsanity,Equipment is randomized until the end of this fight.,YES,NO,NO,NO,YES,var arr = self.getvar(~mqinsanity~); if (arr.length == null) arr = []; self.setvar(~mqinsanity~[;] arr); self.setvar(~mqinsanity_count~[;] status.value);,,,var arr = self.getvar(~mqinsanity~); var equipment = []; if (self.equipment.length > 0) for (eq in self.equipment) if (eq.isready() && eq.skillcard == ~~ && !eq.hastag(~skillcard~)) equipment.push(eq); var c = status.value - arr.length; if (equipment.length > 0) {if (c > 0) sfx(~_mqinsanity~); while (c > 0) {c--; var eq = rand(equipment); var exists = false; if (arr.length > 0) for (x in arr) if (x.eq == eq) {exists = true; break;} if (!exists) arr.push({eq: eq[;] orig: eq.name}); runscript(~megaquest/replaceequipment~[;] [eq[;] rand(getequipmentlist(null[;] [eq.hastag(~small~) ? ~small~ : ~large~][;] [~skillcard~[;] ~excludefromrandomlists~[;] ~robotonly~[;] ~witchonly~[;] ~onceperbattle~[;] ~alternateversion~]))]); eq.animate(~flashandshake~); runscript(~megaquest/textparticle~[;] [eq[;] ~[mqinsanity] Insanity!~[;] 0x9d9d9d]);}} self.setvar(~mqinsanity~[;] arr);,,,,var arr = self.getvar(~mqinsanity~); if (arr.length > 0) for (x in arr) {runscript(~megaquest/replaceequipment~[;] [x.eq[;] x.orig]);} self.setvar(~mqinsanity~[;] 0);,,,var c = self.getvar(~mqinsanity_count~) - status.value; var arr = self.getvar(~mqinsanity~); if (arr.length > 0) while (c > 0) {c--; var x = rand(arr); runscript(~megaquest/replaceequipment~[;] [x.eq[;] x.orig]); x.eq.animate(~flashandshake~); arr.remove(x);} self.setvar(~mqinsanity_count~[;] status.value);
alternate_mqinsanity,Insanity?,mqinsanity,Your attacks also backfire for [mqinsanity]<value>[]x50% damage.,YES,YES,NO,NO,YES,,,,,,,,,if (self.getvar(~mqmyturn~) == 1) {var selfdamage = runscript(~megaquest/math/ceil~[;] [dmg * (0.5 * status.value)]); var eq = runscript(~megaquest/createequipment~[;] [~~[;] false[;] false[;] 3180 / 7 * runscript(~megaquest/math/random~[;] [1[;] 6])[;] -618[;] self[;] true]); eq.displayname = ~Insanity?~; eq.fulldescription = ~Take [sword]~ + selfdamage + ~ damage~; eq.script = ~attackself(~ + selfdamage + ~); sfxdamage(self[;] ~ + selfdamage + ~);~; eq.castdirection = -1; eq.changecolour(~PINK~); eq.changeslots([~NORMAL~]); runscript(~megaquest/snap~[;] [eq[;] self[;] target[;] false]);},,
mqbackstab,mqbackstab,sword,(should not appear),YES,NO,NO,YES,NO,,,,,,,,,,,
mqnumb,Numb,mqnumb,Equipment must be used|in a specific order.,NO,YES,NO,NO,YES,,,if (self.equipment.length > 0) {var availableequipment = []; for (eq in self.equipment) if (eq.getvar(~mqnumb~) == 1) {eq.availablethisturn = true; eq.setvar(~mqnumb~[;] 0);} for (eq in self.equipment) if (eq.ready && eq.availablethisturn && eq.skillcard == ~~) availableequipment.push(eq); if (availableequipment.length > 0) {availableequipment = shuffle(availableequipment); var chosenequipment = availableequipment.pop(); if (availableequipment.length > 0) for (eq in availableequipment) {eq.availablethisturn = false; eq.unavailabletext = eq.displayname + eq.namemodifier; eq.unavailabledetails = [~Unavailable (Numb)~]; eq.setvar(~mqnumb~[;] 1);}}},,if (self.equipmenthistory.length > 0 && self.equipmenthistory[self.equipmenthistory.length - 1].skillcard == ~~) if (self.equipment.length > 0) {var availableequipment = []; for (eq in self.equipment) if (eq.getvar(~mqnumb~) == 1) {eq.availablethisturn = true; eq.setvar(~mqnumb~[;] 0);} for (eq in self.equipment) if (eq.ready && eq.availablethisturn && eq.skillcard == ~~) availableequipment.push(eq); if (availableequipment.length > 0) {availableequipment = shuffle(availableequipment); var chosenequipment = availableequipment.pop(); chosenequipment.animate(~flashandshake~); if (availableequipment.length > 0) for (eq in availableequipment) {eq.availablethisturn = false; eq.unavailabletext = eq.displayname + eq.namemodifier; eq.unavailabledetails = [~Unavailable (Numb)~]; eq.setvar(~mqnumb~[;] 1);}}},,,,,,if (self.equipment.length > 0) for (eq in self.equipment) eq.setvar(~mqnumb~[;] 0);
alternate_mqnumb,Numb?,mqnumb,Each equipment use disables|one random equipment.,NO,YES,NO,NO,YES,,,,,if (self.equipment.length > 0) {var availableequipment = []; for (eq in self.equipment) if (eq.isready() && eq.skillcard == ~~) availableequipment.push(eq); if (availableequipment.length > 0) {var eq = rand(availableequipment); eq.availablethisturn = false; eq.unavailabletext = eq.displayname + eq.namemodifier; eq.unavailabledetails = [~Unavailable (Numb?)~]; eq.animate(~flashandshake~);}},,,,,,if (self.equipment.length > 0) for (eq in self.equipment) eq.setvar(~mqnumb~[;] 0);
